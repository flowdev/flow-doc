package draw

import (
	"bytes"
	"fmt"
	"path/filepath"
	"text/template"
)

const svgDiagram = `<?xml version="1.0" ?>
<svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="{{.X0}} {{.Y0}} {{.TotalWidth}} {{.TotalHeight}}" width="{{.TotalWidth}}px" height="{{.TotalHeight}}px">
    <!-- Generated by FlowDev tool. -->
    <rect fill="rgb(255,255,255)" fill-opacity="1" width="{{.TotalWidth}}" height="{{.TotalHeight}}" x="{{.X0}}" y="{{.Y0}}"/>

{{if .Arrows}}{{end}}
{{- range .Arrows}}
    <line stroke="rgb(0,0,0)" stroke-opacity="1.0" stroke-width="2" x1="{{.X1}}" y1="{{.Y1}}" x2="{{.X2}}" y2="{{.Y2}}"/>
    <line stroke="rgb(0,0,0)" stroke-opacity="1.0" stroke-width="2" x1="{{.XTip1}}" y1="{{.YTip1}}" x2="{{.X2}}" y2="{{.Y2}}"/>
    <line stroke="rgb(0,0,0)" stroke-opacity="1.0" stroke-width="2" x1="{{.XTip2}}" y1="{{.YTip2}}" x2="{{.X2}}" y2="{{.Y2}}"/>
{{end}}
{{- range .Rects}}
{{- if .IsSubRect}}
    <rect fill="rgb(32,224,32)" fill-opacity="1.0" stroke="rgb(0,0,0)" stroke-opacity="1.0" stroke-width="1" width="{{.Width}}" height="{{.Height}}" x="{{.X}}" y="{{.Y}}" rx="10"/>
{{- else -}}
    {{- if .IsPlugin}}
    <rect fill="rgb(224,224,32)" fill-opacity="1.0" stroke="rgb(0,0,0)" stroke-opacity="1.0" stroke-width="2" width="{{.Width}}" height="{{.Height}}" x="{{.X}}" y="{{.Y}}" rx="10"/>
    {{- else}}
    <rect fill="rgb(96,192,255)" fill-opacity="1.0" stroke="rgb(0,0,0)" stroke-opacity="1.0" stroke-width="2" width="{{.Width}}" height="{{.Height}}" x="{{.X}}" y="{{.Y}}" rx="10"/>
    {{- end}}
{{- end}}
{{- end}}
{{range .Texts}}
{{- if .Small}}
    <text fill="rgb(0,0,0)" fill-opacity="1.0" font-size="14" x="{{.X}}" y="{{.Y}}" textLength="{{.Width}}" lengthAdjust="spacingAndGlyphs">{{.Text}}</text>
{{- else}}
    <text fill="rgb(0,0,0)" fill-opacity="1.0" font-size="16" x="{{.X}}" y="{{.Y}}" textLength="{{.Width}}" lengthAdjust="spacingAndGlyphs">{{.Text}}</text>
{{- end}}
{{- end}}
</svg>
`

var svgTmpl = template.Must(template.New("svgDiagram").Parse(svgDiagram))

const mdDiagram = `
{{- if .FlowLines}}
{{- $n := len .FlowLines -}}
{{range $i, $flowLine := .FlowLines}}
    {{- range $cell := $flowLine -}}
        {{- if $cell.Link -}}
            [![{{$cell.Name}}]({{$cell.SVG}})]({{$cell.Link}})
        {{- else -}}
            ![{{$cell.Name}}]({{$cell.SVG}})
        {{- end -}}
    {{- end -}}
    {{- if ne $i $n}}\{{end}}
{{end}}
{{else}}
![{{.Flow.Name}}]({{.Flow.SVG}})
{{end}}
{{- if .DataTypes}}

#### Data Types
{{range $name, $link := .DataTypes}}[{{$name}}]({{$link}}), {{end}}
{{end}}
{{- if .Subflows}}

#### Subflows
{{range $name, $link := .Flows}}[{{$name}}]({{$link}}), {{end}}
{{end}}
{{- if .GoFuncs}}

#### Go Functions and Methods
{{range $name, $link := .GoFuncs}}[{{$name}}]({{$link}}), {{end}}
{{end}}
`

var mdTmpl = template.Must(template.New("mdDiagram").Parse(mdDiagram))

type TextType int

const (
	TextTypeText TextType = iota
	TextTypeLink
	TextTypeGoLink
)

const (
	bigDiagramSize  = 256
	tinyDiagramSize = 8
)

type svgArrow struct {
	X1, Y1       int
	X2, Y2       int
	XTip1, YTip1 int
	XTip2, YTip2 int
}

type svgRect struct {
	X, Y      int
	Height    int
	Width     int
	IsPlugin  bool
	IsSubRect bool
}

type svgText struct {
	X, Y  int
	Width int
	Text  string
	Small bool
	Type  TextType
}

type svgFlow struct {
	X0, Y0      int
	TotalHeight int
	TotalWidth  int
	Arrows      []*svgArrow
	Rects       []*svgRect
	Texts       []*svgText
}

func newSVGFlow(x0, y0, height, width, size int) *svgFlow {
	return &svgFlow{
		X0:          x0,
		Y0:          y0,
		TotalHeight: height,
		TotalWidth:  width,
		Arrows:      make([]*svgArrow, 0, size),
		Rects:       make([]*svgRect, 0, size),
		Texts:       make([]*svgText, 0, size),
	}
}

type svgLink struct {
	Name string
	SVG  string
	Link string
}

type mdFlow struct {
	Flow      svgLink
	FlowLines [][]*svgLink
	DataTypes map[string]string
	Subflows  map[string]string
	GoFuncs   map[string]string
}

func newMDFlow() *mdFlow {
	return &mdFlow{
		FlowLines: make([][]*svgLink, 0, 128),
		DataTypes: make(map[string]string, 256),
		Subflows:  make(map[string]string, 256),
		GoFuncs:   make(map[string]string, 256),
	}
}

type svgMDFlow struct {
	svgs          map[string]*svgFlow
	md            *mdFlow
	svgFilePrefix string
	lastX         int
}

// FromFlowData creates a set of SVG diagrams and a MarkDown file from flow
// data. If the flow data isn't valid or the SVG diagrams or the MarkDown file
// can't be created with their template, an error is returned.
func FromFlowData(f *Flow, mode FlowMode, width int, dark bool,
) (svgContents map[string][]byte, mdContent []byte, err error) {

	err = validateFlowData(f)
	if err != nil {
		return nil, nil, err
	}

	f.mode = mode
	f.width = width
	f.dark = dark

	enrichFlow(f)
	smf := flowToSVGs(f)
	if f.mode != FlowModeSVGLinks {
		smf.svgs[smf.svgFilePrefix+".svg"] = smf.svgs[""]
		delete(smf.svgs, "")
	}

	svgContents, err = svgFlowsToBytes(smf.svgs)
	if err != nil {
		return nil, nil, err
	}
	mdContent, err = mdFlowToBytes(smf.md)
	if err != nil {
		return nil, nil,
			fmt.Errorf("unable to create MarkDown content for %q flow: %w", f.Name, err)
	}
	return svgContents, mdContent, nil
}

func enrichFlow(f *Flow) {
	merges := make(map[string]*Merge)
	enrichSplit(f.AllShapes, 0, 0, 0, nil, FlowModeNoLinks, merges,
		enrichArrow, enrichOp, enrichMerge)
}

func flowToSVGs(f *Flow) *svgMDFlow {
	smf := &svgMDFlow{
		svgs:          make(map[string]*svgFlow, 256),
		md:            newMDFlow(),
		svgFilePrefix: filepath.Join(".", "flowdev", "flow-"+f.Name),
	}
	fd := f.AllShapes.drawData

	if f.mode != FlowModeSVGLinks {
		smf.md.Flow = svgLink{
			Name: f.Name,
			SVG:  smf.svgFilePrefix + ".svg",
		}
		svg := newSVGFlow(0, 0, fd.height, fd.width, bigDiagramSize)
		smf.svgs[""] = svg
	}

	minLine := fd.minLine
	maxLine := minLine + fd.lines - 1
	for line := minLine; line <= maxLine; line++ {
		smf.lastX = 0
		splitToSVG(smf, line, f.mode, f.AllShapes)

		if smf.lastX < f.AllShapes.drawData.width {
			addFillerSVG(smf, line, smf.lastX, LineHeight,
				f.AllShapes.drawData.width-smf.lastX)
		}
	}
	return smf
}

func svgFlowsToBytes(sfs map[string]*svgFlow) (map[string][]byte, error) {
	sfbs := make(map[string][]byte)
	for key, sf := range sfs {
		bs, err := svgFlowToBytes(sf)
		if err != nil {
			return nil, fmt.Errorf("unable to create SVG file %q: %w", key, err)
		}
		sfbs[key] = bs
	}
	return sfbs, nil
}

func svgFlowToBytes(sf *svgFlow) ([]byte, error) {
	buf := bytes.Buffer{}
	err := svgTmpl.Execute(&buf, sf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func mdFlowToBytes(mdf *mdFlow) ([]byte, error) {
	buf := bytes.Buffer{}
	err := mdTmpl.Execute(&buf, mdf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// --------------------------------------------------------------------------
//    U T I L s :
// --------------------------------------------------------------------------
func addFillerSVG(smf *svgMDFlow, line, x, height, width int) {
	svg := newSVGFlow(0, 0, height, width, tinyDiagramSize)
	name := svgFileName(smf, "filler", x, line)

	smf.svgs[name] = svg
	addSVGLinkToMDFlowLines(smf, line, name, "filler")
}

func addSVGLinkToMDFlowLines(smf *svgMDFlow, line int, svgName, desc string) *svgLink {
	l := len(smf.md.FlowLines)
	if l <= line {
		for i := l; i <= line; i++ { // fill up lines as necessary (should only be one)
			smf.md.FlowLines = append(smf.md.FlowLines, make([]*svgLink, 0, 32))
		}
	}
	sl := &svgLink{
		Name: desc,
		SVG:  svgName,
	}
	smf.md.FlowLines[line] = append(smf.md.FlowLines[line], sl)

	return sl
}

func svgFileName(smf *svgMDFlow, compName string, x, line int) string {
	if compName == "" {
		return fmt.Sprintf("%s-%d-%d.svg", smf.svgFilePrefix, x, line)
	}
	if x < 0 {
		return fmt.Sprintf("%s-%s-%d.svg", smf.svgFilePrefix, compName, line)
	}
	return fmt.Sprintf("%s-%s-%d-%d.svg", smf.svgFilePrefix, compName, x, line)
}

func maximumLine(d *drawData) int {
	return d.minLine + d.lines - 1
}

func withinShape(line int, d *drawData) bool {
	return d.minLine <= line && line < d.minLine+d.lines
}

func min(a, b int) int {
	if a <= b {
		return a
	}
	return b
}
func max(a, b int) int {
	if a >= b {
		return a
	}
	return b
}
